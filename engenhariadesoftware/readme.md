# Comentários (Software Engineering at Google, Oreilly)

### Dia 13/02

* Atividade 1: Comentar com suas palavras o primeiro trecho do livro.

O texto implica a popularização da atuação das pessoas nas áreas de programação, com foco em Engenharia de Software. Além disso, faz uma análise introdutória comparando a Engenharia de Software com as demais engenharias muito presentes no mercado. Essa análise, diz que as engenharias são muito rígidas, a fim de manter a mais rigorosa segurança de seus produtos e subentende que a Engenharia de Software deveria seguir esse caminho, visto que a programação de sistemas está cada vez mais presente no nosso dia a dia, ou seja, um dia, começaremos a depender dela, o que causará problemas de segurança se não houver regras rígidas para a criação dentro dessa área.


* Atividade 2: Comentar com suas palavras o segundo trecho do livro.

O texto explica a dificuldade em atingir um nível de "robusteza" dos softwares. Há necessidade dos sitemas serem mais adaptáveis e sustentáveis, gerando confiança em suas funcionlidades, com maior facilidade de manutenção e adaptabilidade à modernidade. Hoje (na época em que as páginas foram escritas), não obtveram muitas respostas, mas apostam em alguns pilares para atingir essas metas, como Tempo e Mudanças, Crescimento e Adaptabilidade e Custos vs Compensações, os quais são caminhos possíveis para atingir uma robusteza importante para perpetualibilidade dos softwares.

### Dia 20/02

* Atividade 3: Citar e explicar 5 requisitos não funcionais.

Auditabilidade: o sistema deve conter funcionalidades seguras nas quais permitam que os clientes sejam capazes de verificar todas as infimações sensíveis relacionadas às suas entradas.

Usabilidade: Facilidade na vizualização e manuseio do softwares. O importante é que os clientes possam enternder o sistema de forma intuitiva, gerando agilidade no uso e evitando erros e lentidões.

Escalabilidade: Os softwares, hoje, tem o desafio de conseguir se manter online mesmo com o crescimento exponencial de acessos. Desafio esse, que é um dos pilares essenciais para a durabilidade e sustentabilidade de um sitema, onde ele se torna auto regulável.

Testabilidade: O sistema deve oferecer formas de testes contra erros de forma simples e rápida, a fim de evitar o máximo possível de erros e bugs, para isso, deverão ser pensados diversos testes durante a programação do software.

Recuperabilidade: A fim de evitar riscos de invasão e desconfiança dos clientes, o sitema necessita de reações às adversidades como queda de servidor, back up e etc
sem contar no número de informações que seriam perdidas.

* Atividade 4: Citar 3 cenários distintos de trade-offs.

1. Utilização de linguagem C, afim de possuir outros sistemas compatíveis;
2. Utilização de repositório para o código, afim de controlar os bugs e erros, garantir atualizações e melhorias e garantir a perpetuabilidade do código;
3. Design adequado à utilização sensorial, a fim de tornar o software simples de se utilizar por qualquer pessoa/ cliente.

### Dia 23/02

* Atividade 5: "É possível testar tudo?"

Não seria possível testar tudo, visto que a gama de possibilidades que não demonstram o erro é imensa. Acrescentando, a gama de opção que mostram o erro, são apenas 3, no qual seriam dentro das extremidades próximas a 30000. Temos que, se realizarmos a divisão por 30000 dos numeros 29999, 30000 e -29999, temos resultados diferentes dos esperados, que seriam 1 e 0. Logo, não seria possível testar todos, visto que números baixos dariam resultados esperados.
